\documentclass[a4paper,12pt]{article}
\usepackage{cmap}
\usepackage[cp1251]{inputenc}
\usepackage[english, ukrainian, russian]{babel}
\usepackage[left=1cm,right=1cm,top=1cm,bottom=1cm]{geometry}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\begin{document}

\pagenumbering{gobble}


\begin{center}
\section*{Теорія розподілених баз даних.}
\end{center}


\bigskip

\hrule

\medskip
\medskip
\begin{enumerate}

\item Реляційні бази даних. Нормалізація

\item Транзакції. Принцип ACID.

\item 2PC та 3PC протоколи в розподілених системах. Паттерн Saga. \\ (https://medium.com/@ys.meng/understanding-two-phase-and-three-phase-commit-protocols-in-distributed-systems-33a39bca7688)

\item Використання NoSQL. CAP теорема.

\item Масштабування. Горизонтальне та вертикальне масштабування.

\item Розподілення та синхронізація, конзистентність даних. Мікросервісна архітектура. Використання Kafka.

\end{enumerate}


\medskip

\hrule height 1pt
\vskip 3pt \hrule
\medskip
\medskip

\medskip

\begin{center}
\textbf{Реляційні бази даних. Нормалізація.}
\end{center}

\textbf{1. Вступ}

Мета лекції: Ознайомити студентів з основними концепціями реляційних баз даних та процесом нормалізації.

Основні теми:

\begin{itemize}
\item Реляційна модель даних.

\item Функціональні залежності.

\item Процес нормалізації.

\item Нормальні форми.
\end{itemize}



\textbf{2. Реляційна модель даних}

Поняття реляційної моделі:

Основні елементи: Таблиця (реляція), рядок (кортеж), стовпець (атрибут).

Таблиці як моделі об'єктів та їх властивостей.

Ключі:
Первинний ключ: Унікальний ідентифікатор для кожного запису в таблиці.
Зовнішній ключ: Поле, що посилається на первинний ключ іншої таблиці, використовується для реалізації зв'язків між таблицями.

Типи зв'язків між таблицями:

\begin{itemize}
\item Один до одного (1:1)

\item Один до багатьох (1)

\item Багато до багатьох (M)
\end{itemize}


\textbf{3. Функціональні залежності}

Визначення:
Функціональна залежність (ФЗ) – це зв'язок між атрибутами таблиці, при якому значення одного атрибуту визначає значення іншого.

Типи функціональних залежностей:

\begin{itemize}
\item Повна функціональна залежність (для первинних ключів).

\item Часткова функціональна залежність (для неключових атрибутів).

\item Транзитивна функціональна залежність (опосередковані залежності).

\item Приклади функціональних залежностей на реальних даних.
\end{itemize}



\textbf{4. Процес нормалізації}

Мета нормалізації: Усунення аномалій додавання, видалення та оновлення даних шляхом розділення даних на логічні таблиці.
Етапи нормалізації:

\begin{itemize}
\item Перша нормальна форма (1NF): Таблиця не містить повторюваних груп або мультизначних атрибутів.

\item Друга нормальна форма (2NF): Усі неключові атрибути повністю залежать від первинного ключа (немає часткових залежностей).

\item Третя нормальна форма (3NF): Відсутність транзитивних залежностей між атрибутами.

\item Бойс-Коддова нормальна форма (BCNF): Розширення 3NF з додатковим умовами для складних ключів.

\item Четверта нормальна форма (4NF): Усунення багатозначних залежностей.

\item П'ята нормальна форма (5NF): Усунення залежностей з'єднання.
\end{itemize}



\textbf{5. Приклади нормалізації}

Приклад таблиці без нормалізації: Описати таблицю, де наявні функціональні залежності та аномалії оновлення.

Процес нормалізації: Показати, як таблиця перетворюється на нормальні форми, застосовуючи правила кожної нормальної форми.

Візуалізація: Графічно зобразити схеми таблиць до і після нормалізації.



\textbf{6. Проблеми денормалізації}

Причини денормалізації: Пояснити, чому в деяких випадках бази даних можуть бути денормалізовані для покращення продуктивності.

Приклади денормалізації: Випадки, коли потрібно скоротити кількість джоінів або уникати складних запитів.



\textbf{7. Заключення}

Підсумок: Огляд основних етапів нормалізації та їх значення для створення ефективних і логічно послідовних баз даних.

Дискусія: Обговорення можливих питань щодо оптимізації баз даних та їх використання на практиці.





\newpage

\begin{center}
\textbf{Транзакції. Принцип ACID.}
\end{center}

\textbf{1. Вступ}

Мета лекції: Ознайомити студентів із поняттям транзакцій у базах даних, їх важливістю для розподілених систем, та розглянути детально принцип ACID.

Основні теми:

\begin{itemize}
\item Транзакції в базах даних.

\item Принципи ACID.

\item Реалізація транзакцій в розподілених системах.

\item Конфлікти та відновлення транзакцій.
\end{itemize}



\textbf{2. Поняття транзакцій у базах даних}

Визначення транзакції: Транзакція – це послідовність операцій з базою даних, які розглядаються як єдина логічна одиниця роботи.

Властивості транзакції:
Логічна цілісність: транзакція або виконується повністю, або не виконується взагалі.
Транзакції можуть містити кілька операцій запису, читання, оновлення або видалення даних.

Типи транзакцій:

Простий (одинарний) запит.

Мультизапитні транзакції.

Приклади транзакцій:

Грошовий переказ між рахунками.

Оформлення замовлення в інтернет-магазині.





\textbf{3. Принцип ACID}

ACID (Атомарність, Узгодженість, Ізоляція, Стійкість):

\begin{itemize}
\item Атомарність (Atomicity):
Суть: Транзакція виконується повністю або не виконується зовсім. Якщо відбувається збій, усі зміни відкатуються.
Приклад: Якщо один етап переказу грошей на банківський рахунок не виконався, вся транзакція буде скасована.

\item Узгодженість (Consistency):
Суть: Транзакція переводить базу даних з одного узгодженого стану в інший. Після завершення транзакції дані мають відповідати правилам цілісності.
Приклад: Після оновлення обліку на складі кількість товарів завжди має бути вірною.

\item Ізоляція (Isolation):
Суть: Кожна транзакція виконується незалежно від інших, навіть якщо вони відбуваються одночасно.
Рівні ізоляції:
Read Uncommitted (читає незавершені зміни)
Read Committed (читає тільки завершені зміни)
Repeatable Read (гарантує однаковий результат для повторного читання)
Serializable (максимальний рівень ізоляції)

\item Стійкість (Durability):
Суть: Після завершення транзакції її результати зберігаються навіть у випадку збою системи.
Приклад: Якщо транзакція записала зміни в базу даних, вони залишаться там навіть після перезавантаження сервера.
\end{itemize}




\textbf{4. Реалізація транзакцій в розподілених базах даних}

\begin{itemize}
\item Проблеми розподілених транзакцій:

База даних може бути розподілена між різними серверами, що ускладнює підтримку ACID.
Необхідність координації між вузлами для забезпечення узгодженості.
Двохфазний протокол фіксації (Two-Phase Commit):

\item Фаза підготовки: Всі учасники готуються до виконання транзакції та повідомляють координатору про готовність.

\item Фаза фіксації: Координатор вирішує, чи можна завершити транзакцію (усі мають бути готові), або відкочує зміни.

\item Протокол Paxos та інші механізми консенсусу: Використовуються для забезпечення узгодженості в умовах розподілених систем.
\end{itemize}


\textbf{5. Конфлікти та відновлення транзакцій}

\begin{itemize}
\item Конфлікти транзакцій:

\item Читання "брудних" даних: Коли одна транзакція читає незавершені зміни іншої.

\item Невирішені залежності: Одна транзакція блокує іншу через спільний доступ до даних.

Рішення: Забезпечення ізоляції через блокування або застосування рівнів ізоляції.

\item Відновлення транзакцій:
Методи відновлення:
Журнал транзакцій: Ведення журналу для відслідковування всіх змін у базі даних, щоб можна було відкотити у разі збою.

\item Checkpointing: Збереження стану системи у певний момент часу для прискорення відновлення після збою.
\end{itemize}



\textbf{6. Приклади розподілених систем з підтримкою ACID}

Приклад №1: Реляційні бази даних (PostgreSQL, MySQL) з підтримкою транзакцій.

Приклад №2: NoSQL бази даних з підтримкою транзакцій (Cassandra, MongoDB).
Порівняння: Важливість балансування між вимогами до ACID та вимогами продуктивності у великих розподілених системах.



\textbf{7. Заключення}

Підсумок: Принцип ACID забезпечує надійність і стабільність баз даних, що є важливим аспектом, особливо у розподілених системах.

Дискусія: Можливості й обмеження транзакцій у розподілених середовищах.





\newpage

\begin{center}
\textbf{2PC та 3PC протоколи в розподілених системах. Паттерн Saga. }
\end{center}


\textbf{1. Вступ}

Мета лекції: Ознайомити студентів з основними протоколами координації транзакцій у розподілених системах, а також розглянути паттерн Saga для управління довготривалими транзакціями.

Основні теми:

\begin{itemize}
\item Протокол двофазного підтвердження (2PC).

\item Протокол трьохфазного підтвердження (3PC).

\item Паттерн Saga для довготривалих транзакцій.
\end{itemize}



\textbf{2. Протокол двофазного підтвердження (2PC)}

\begin{itemize}
\item Призначення: Протокол використовується для координації транзакцій у розподілених системах, забезпечуючи узгодженість даних.

\item Фази 2PC:
Фаза підготовки (Prepare phase):
Координатор надсилає запит до всіх учасників транзакції з питанням, чи готові вони виконати зміни.
Кожен учасник перевіряє умови транзакції і повертає "готовий" або "не готовий".
Фаза підтвердження (Commit phase):
Якщо всі учасники відповіли "готовий", координатор надсилає команду "commit" (підтвердити транзакцію).
Якщо хоча б один учасник відповідає "не готовий", координатор надсилає команду "rollback" (відкотити транзакцію).

\item Переваги 2PC:
Простота реалізації.
Висока гарантія узгодженості.

\item Недоліки 2PC:
Блокування ресурсів: Учасники можуть тривалий час чекати на підтвердження транзакції.
Проблеми з відмовами: У випадку збою координатора або учасника транзакції система може залишитися у стані невизначеності.
\end{itemize}




\textbf{3. Протокол трьохфазного підтвердження (3PC)}

\begin{itemize}
\item Мета 3PC: Удосконалення протоколу 2PC для усунення його недоліків у випадках відмов у розподілених системах.

\item Фази 3PC:
Фаза підготовки (CanCommit phase):
Подібна до фази підготовки у 2PC, але координатор отримує попередні зобов’язання.
Фаза попереднього підтвердження (PreCommit phase):
Якщо всі учасники готові, координатор надсилає сигнал "PreCommit", що змушує учасників підготуватися до коміту, але не виконувати його.
Фаза підтвердження (Commit phase):
Якщо координатор не зазнав збою, він надсилає сигнал "Commit". Якщо виникає збій до підтвердження, система може безпечно відкотитися.

\item Переваги 3PC:
Запобігання блокуванню: Учасники не блокують свої ресурси на невизначений час, як це можливо у 2PC.
Відновлення після збоїв: 3PC забезпечує механізми для уникнення зупинки системи у випадку збоїв на будь-якому етапі.

\item Недоліки 3PC:
Складніша реалізація порівняно з 2PC.
Підвищена затримка через додаткову фазу комунікації.
\end{itemize}




\textbf{4. Паттерн Saga}

\begin{itemize}
\item Призначення: Паттерн Saga використовується для управління довготривалими транзакціями у розподілених системах, де неможливо чи непрактично використовувати традиційні транзакційні механізми, такі як 2PC або 3PC.
    
\item Типи Saga:
Оркестраційна Saga: Існує центральний оркестратор, який керує виконанням транзакцій та їх відкатом у разі помилки.
Хореографічна Saga: Кожен учасник самостійно викликає наступний крок, реагуючи на попередню операцію.
Механізм роботи Saga:
Транзакція розбивається на кілька кроків, кожен з яких є незалежним та атомарним.
Для кожного кроку визначається компенсуюча операція, яка виконується у випадку збою.

\item Приклад: В e-commerce системах Saga може використовуватися для управління транзакціями, що охоплюють замовлення, оплату, доставку і повернення товару.
    
\item Переваги паттерну Saga:
Легкість у масштабуванні: Менші транзакції не блокують один одного.
Асиметричний контроль: Кожна операція має свою компенсацію, що знижує ризики глобальних відмов.

\item Недоліки паттерну Saga:
Складність у реалізації компенсацій: Важливо правильно проектувати компенсуючі операції, щоб уникнути непослідовностей.
Необхідність в узгодженості: Немає гарантії глобальної узгодженості, як у 2PC або 3PC.
\end{itemize}




\textbf{5. Порівняння 2PC, 3PC та Saga}

2PC vs. 3PC:
Простота: 2PC простіший у реалізації, але має проблеми з відмовами.
Безпека: 3PC запобігає блокуванню та дозволяє більш ефективне відновлення після збоїв.

2PC/3PC vs. Saga:
ACID vs. BASE: 2PC і 3PC дотримуються строгих принципів ACID, тоді як Saga більше підходить для архітектур BASE (Basically Available, Soft state, Eventual consistency).
Продуктивність: Saga краще підходить для великих і масштабованих систем, де важливі продуктивність і швидкість, а не строгі гарантії консистентності.




\textbf{6. Приклади застосування}

\begin{itemize}
\item 2PC у банківських системах: Використовується для обробки грошових переказів, де важлива узгодженість та надійність.

\item 3PC у системах з високою надійністю: Застосовується в розподілених системах для забезпечення транзакцій у реальному часі.

\item Saga в мікросервісах: Паттерн Saga часто використовується для забезпечення довготривалих бізнес-процесів у мікросервісних архітектурах, таких як управління замовленнями в e-commerce платформах.
\end{itemize}




\textbf{7. Заключення}

Підсумок: Огляд протоколів координації транзакцій (2PC, 3PC) і паттерну Saga, їх застосування у розподілених системах та переваги/недоліки у контексті різних типів систем.

Дискусія: Обговорення різних підходів до управління транзакціями та їх застосування у сучасних розподілених системах.






\newpage

\begin{center}
\textbf{Використання NoSQL. CAP теорема.}
\end{center}

\textbf{1. Вступ}

Мета лекції: Ознайомити студентів із особливостями NoSQL баз даних, їх перевагами та обмеженнями, а також розглянути CAP теорему як основну концепцію для проектування розподілених систем.

Основні теми:

\begin{itemize}
\item Види NoSQL баз даних.

\item Порівняння NoSQL та реляційних баз даних.

\item CAP теорема.
Приклади застосування NoSQL баз даних.
\end{itemize}


\textbf{2. Вступ до NoSQL}

Що таке NoSQL?
NoSQL означає "Not Only SQL", що підкреслює альтернативні підходи до зберігання та управління даними порівняно з традиційними реляційними базами.
Підтримка нефіксованої структури даних, що робить NoSQL ефективними для великих розподілених систем.

Причини використання NoSQL баз:

\begin{itemize}
\item Велика кількість даних, що не підходять для реляційної моделі.

\item Висока масштабованість та продуктивність.

\item Гнучка модель даних, яка дозволяє швидко змінювати схеми.

\item Підтримка горизонтального масштабування (sharding).
\end{itemize}

Основні особливості NoSQL:
Відсутність фіксованих схем.
Горизонтальне масштабування.
Висока доступність і швидкість читання/запису.

Види NoSQL баз даних:

\begin{itemize}
\item Документні бази даних: MongoDB, CouchDB.

\item Ключ-значення: Redis, Amazon DynamoDB.

\item Графові бази даних: Neo4j, Amazon Neptune.

\item Колонкові сховища: Cassandra, HBase.
\end{itemize}




\textbf{3. Порівняння NoSQL та реляційних баз даних}

Реляційні бази даних:

Вимагають жорстко визначених схем і підтримують складні запити (SQL).
Відмінно підходять для транзакцій, де важливі властивості ACID.

Застосування: банківські системи, ERP-системи.

NoSQL бази даних:

Гнучкі моделі даних, можливість зберігати неструктуровану інформацію.
Часто використовують принципи BASE (Basically Available, Soft state, Eventual consistency).
Застосування: соціальні мережі, системи рекомендацій, IoT.





\textbf{4. CAP теорема}

Суть CAP теореми:
Теорема запропонована Еріком Брюером у 2000 році, і вона стверджує, що у розподілених системах неможливо одночасно досягти трьох властивостей:

\begin{itemize}
\item Consistency (Узгодженість): Кожен вузол бачить ті самі дані в будь-який момент часу.

\item Availability (Доступність): Кожен запит отримує відповідь (успішну або невдалу) у визначений час.

\item Partition tolerance (Стійкість до розділення): Система продовжує працювати, навіть якщо є проблеми з мережевим з'єднанням між вузлами.
\end{itemize}

CAP теорема стверджує, що система може забезпечувати одночасно тільки дві з цих властивостей.

Розшифрування трьох властивостей:

\begin{itemize}
\item Узгодженість (Consistency):
Всі вузли системи повинні мати однакові дані.
Приклад: в реляційних БД узгодженість досягається через транзакції (ACID).

\item Доступність (Availability):
Система завжди відповідає на запити, навіть якщо не всі вузли синхронізовані.

\item Стійкість до розділення (Partition Tolerance):
Система продовжує працювати, навіть якщо є розриви у мережі або зв'язок між деякими вузлами недоступний.
\end{itemize}

Приклади розподілених систем з різними комбінаціями CAP:

\begin{itemize}
\item CA (Consistency + Availability):
Системи без стійкості до розділення.
Приклад: традиційні реляційні бази даних, які не підтримують масштабування у разі розподілу.

\item CP (Consistency + Partition tolerance):
Гарантія узгодженості і стійкості до розділення, але можуть бути проблеми з доступністю під час збоїв у мережі.
Приклад: HBase.

\item AP (Availability + Partition tolerance):
Висока доступність і стійкість до розділення, але можлива відсутність моментальної узгодженості.
Приклад: Cassandra, DynamoDB.
\end{itemize}




\textbf{5. Приклади використання NoSQL баз даних з урахуванням CAP}

\begin{itemize}
\item MongoDB (AP):
Забезпечує високу доступність та стійкість до розділення, але можливі затримки в узгодженні даних у розподілених середовищах.

\item Cassandra (AP):
Вибір на користь доступності та стійкості до розділення, що підходить для великих розподілених систем із великими навантаженнями на запис.

\item HBase (CP):
Віддає перевагу узгодженості та стійкості до розділення, але може відмовлятися відповідати на запити під час збоїв у мережі.

\item Redis (CA):
Працює з високою узгодженістю і доступністю, проте не витримує добре розподілення даних у великих системах.
\end{itemize}




\textbf{6. CAP теорема і підходи BASE в NoSQL}

\begin{itemize}
\item BASE (Basically Available, Soft state, Eventual consistency):
Підхід, що використовується в NoSQL базах для балансування між доступністю та узгодженістю.

\item Basically Available: Система завжди відповідає на запити.

\item Soft state: Стан системи може бути змінним (не фіксованим).

\item Eventual consistency: З часом дані синхронізуються між усіма вузлами.

\item Відмінності від ACID:
BASE допускає тимчасові непослідовності, що дозволяє системам працювати швидше та ефективніше при масштабуванні.
Підходить для застосувань, де швидкість і масштабованість важливіші за повну узгодженість.
\end{itemize}




\textbf{7. Заключення}

Підсумок: NoSQL бази даних пропонують гнучкість та ефективність для розподілених систем, тоді як CAP теорема допомагає розробникам балансувати між доступністю, узгодженістю та стійкістю до розділення.

Дискусія: Як обрати NoSQL базу даних відповідно до вимог до системи та обмежень, які накладає CAP теорема.





\newpage

\begin{center}
\textbf{Масштабування. Горизонтальне та вертикальне масштабування.}
\end{center}

\textbf{1. Вступ}

Мета лекції: Ознайомити студентів з основними підходами до масштабування баз даних і розподілених систем, а також детально розглянути поняття горизонтального та вертикального масштабування.

Основні теми:

\begin{itemize}
\item Масштабування як основа продуктивності та надійності систем.

\item Вертикальне масштабування.

\item Горизонтальне масштабування.

\item Переваги та недоліки кожного типу масштабування.
\end{itemize}




\textbf{2. Що таке масштабування?}

Визначення масштабування: Процес розширення системи для обробки більших обсягів даних або підвищення продуктивності, збільшення навантаження або кількості користувачів.

\textit{Чому масштабування важливе?}

\begin{itemize}
\item Зростання обсягів даних (Big Data).

\item Підвищення кількості одночасних користувачів.

\item Забезпечення високої доступності та продуктивності системи.
\end{itemize}

\textit{Основні підходи до масштабування:}

Вертикальне масштабування (Scaling Up): Збільшення потужностей одного сервера.

Горизонтальне масштабування (Scaling Out): Додавання нових серверів для розподілення навантаження.




\textbf{3. Вертикальне масштабування}

\begin{itemize}
\item \textit{Що таке вертикальне масштабування?}
Збільшення ресурсів на одному сервері: більше процесорів, оперативної пам’яті, жорсткого диска тощо.
Підвищення продуктивності окремої машини.

\item \textit{Приклад вертикального масштабування:}
Заміна сервера з 16 ГБ оперативної пам'яті на сервер з 64 ГБ або оновлення процесорів до більш потужних.

\item \textit{Переваги вертикального масштабування:}
Простота: Немає необхідності змінювати архітектуру програми.
Цілісність: Усі дані залишаються на одному сервері, що спрощує управління транзакціями та узгодженістю.

\item \textit{Недоліки вертикального масштабування:}
Вартість: Висока вартість обладнання, оскільки високопродуктивне обладнання дороге.
Обмеження масштабування: Існує фізична межа апаратних можливостей, до якої можна збільшувати ресурси.
Єдина точка відмови (SPOF): Якщо сервер виходить з ладу, вся система може зупинитися.
\end{itemize}




\textbf{4. Горизонтальне масштабування}

\textit{Що таке горизонтальне масштабування?}
Додавання нових серверів (вузлів) у систему для розподілення навантаження.
Розподілення даних та запитів між кількома серверами.

\textit{Приклад горизонтального масштабування}:
Розподілення бази даних на кілька вузлів за допомогою шардингу або реплікації.

\textit{Моделі горизонтального масштабування}:

Шардинг (Sharding): Розбиття даних на окремі частини (шарди), кожна з яких зберігається на різних серверах.

Реплікація: Створення кількох копій одних і тих самих даних на різних серверах для підвищення доступності та продуктивності.

Переваги горизонтального масштабування:

\begin{itemize}
\item Масштабованість: Можна додавати нові сервери практично без обмежень.

\item Відмовостійкість: Дані розподілені між серверами, тому вихід одного вузла не впливає на роботу всієї системи.

\item Еластичність: Можливість легко збільшувати або зменшувати кількість серверів у залежності від навантаження.
\end{itemize}

\textit{Недоліки горизонтального масштабування:}

\begin{itemize}
\item Складність управління: Необхідність зміни архітектури системи, розподілення даних і координація запитів.

\item Проблеми з узгодженістю: Необхідність узгодження даних між різними серверами (особливо при реплікації).

\item Затримки в комунікації: Можуть виникати додаткові затримки через взаємодію між вузлами.
\end{itemize}





\textbf{5. Приклади застосування масштабування}

\textit{Вертикальне масштабування:}
Традиційні реляційні бази даних: Витримують навантаження на одному сервері.

Приклад: Реляційна БД у малому або середньому бізнесі з постійним навантаженням, де збільшення ресурсів одного сервера може вирішити всі проблеми.

\textit{Горизонтальне масштабування:}

NoSQL бази даних: Системи, що використовують шардинг і реплікацію для розподілення даних.
Приклад: Системи, що обробляють великі обсяги даних у реальному часі, такі як соціальні мережі (Facebook, Twitter), інтернет-магазини (Amazon).




\textbf{6. Балансування між масштабуванням та узгодженістю}

\textit{CAP теорема і масштабування:}
Важливість вибору між узгодженістю, доступністю та стійкістю до розділення при масштабуванні системи.

Горизонтальне масштабування часто призводить до компромісів між узгодженістю та доступністю через розподілену природу даних.

\textit{Модель BASE (Basically Available, Soft state, Eventual consistency):}
Використовується в розподілених системах для підтримки високої доступності та стійкості до розділення на шкоду миттєвій узгодженості.




\textbf{7. Заключення}

\textit{Підсумок:} Вертикальне масштабування підходить для менш складних систем з високою продуктивністю на одному сервері, тоді як горизонтальне масштабування є ключовим для великих розподілених систем. Важливо враховувати компроміси між узгодженістю, доступністю та продуктивністю під час проектування масштабованих систем.

\textit{Дискусія:} Коли варто обирати горизонтальне масштабування, а коли — вертикальне?








\newpage

\begin{center}
\textbf{Розподілення та синхронізація, конзистентність даних. Мікросервісна архітектура. Використання Kafka.}
\end{center}

\textbf{1. Вступ}

\textit{Мета лекції}: Ознайомити студентів з основами розподілення даних у системах, методами синхронізації та забезпечення консистентності даних, а також з мікросервісною архітектурою та роллю Kafka в таких системах.

\textit{Основні теми:}

Розподілення та синхронізація даних.

Методи забезпечення консистентності даних.

Мікросервісна архітектура.

Використання Apache Kafka для передачі даних у розподілених системах.




\textbf{2. Розподілення даних у системах}

\textit{Що таке розподілені системи?}
Система, в якій компоненти розташовані на різних серверах або вузлах, що працюють разом як єдина система.

\textit{Мета розподілення}: Підвищення масштабованості, надійності та продуктивності.

\textit{Розподілення даних:}

Шардинг: Розбиття даних на частини для зберігання на різних вузлах.

Реплікація: Копіювання даних між вузлами для підвищення відмовостійкості.

\textit{Виклики розподілення}:

Забезпечення узгодженості даних між вузлами.
Синхронізація транзакцій у системах з високим навантаженням.
Зниження затримок при доступі до розподілених даних.




\textbf{3. Синхронізація та консистентність даних}

\textit{Поняття консистентності:}

Консистентність означає, що всі вузли системи мають однакові дані в будь-який момент часу.
Проблеми синхронізації в розподілених системах:
Затримки мережі: Дані можуть не синхронізуватися миттєво через проблеми мережі або велике навантаження.

\textit{Часткове оновлення:} Можуть виникати ситуації, коли один вузол має нові дані, а інший – старі.
Методи забезпечення консистентності:

\begin{itemize}
\item Strong Consistency (Сильна консистентність): Усі вузли завжди бачать однакові дані після виконання операції (наприклад, через двофазний протокол фіксації).

\item Eventual Consistency (Кінцева консистентність): Всі вузли в кінцевому підсумку синхронізуються, хоча можуть тимчасово містити різні дані.

\item CAP теорема: Необхідність вибору між консистентністю, доступністю та стійкістю до розділення в розподілених системах.
\end{itemize}




\textbf{4. Мікросервісна архітектура}

\textit{Що таке мікросервіси?}
Архітектурний стиль, при якому застосунок розбивається на окремі незалежні сервіси, кожен з яких виконує окрему бізнес-функцію.
Мікросервіси можуть розроблятися, тестуватися та розгортатися незалежно один від одного.

\textit{Переваги мікросервісної архітектури:}

Гнучкість: Легше впроваджувати зміни або додавати нові функції.

Масштабованість: Можливість масштабувати кожен сервіс окремо.
Незалежний розвиток: Команди можуть працювати над окремими мікросервісами незалежно.

\textit{Виклики мікросервісів:}

Консистентність даних: Узгодженість даних між різними сервісами є складним завданням, оскільки кожен сервіс може мати власну базу даних.

Синхронізація: Складність координації між мікросервісами, особливо при розподілених транзакціях.

Моніторинг і управління: Потрібні інструменти для відстеження стану кожного сервісу та управління їх взаємодією.

\textit{Роль асинхронної комунікації:} Мікросервіси часто використовують асинхронні механізми обміну повідомленнями для зменшення залежностей між компонентами (наприклад, через черги повідомлень).




\textbf{5. Використання Apache Kafka у мікросервісній архітектурі}

\textit{Що таке Apache Kafka?}
Розподілена платформа обміну повідомленнями, що дозволяє забезпечити надійний обмін великими обсягами даних у реальному часі між різними системами.
Kafka дозволяє продуцентам надсилати повідомлення до певних тем (topics), а споживачі можуть підписуватися на ці теми та отримувати повідомлення.

Основні компоненти Kafka:
\begin{itemize}
\item Продюсери (Producers): Відправляють повідомлення до Kafka.

\item Брокери (Brokers): Сервери, які зберігають повідомлення та управляють темами.

\item Споживачі (Consumers): Читають повідомлення з тем та обробляють їх.

\item Теми (Topics): Канали, через які передаються повідомлення.
\end{itemize}

\textit{Переваги Kafka для мікросервісної архітектури:}

Асинхронна комунікація: Сервіси можуть обмінюватися повідомленнями в асинхронному режимі, що знижує залежність між ними.

Масштабованість: Kafka легко масштабується для обробки великого обсягу повідомлень.

Висока продуктивність: Підтримує тисячі повідомлень в секунду завдяки партиціям та реплікації.

\textit{Приклади використання Kafka:}

Логи та моніторинг: Збір та передача логів у реальному часі.

Стримінг даних: Реалізація систем потокової обробки великих даних.

Інтеграція мікросервісів: Використання Kafka як "шини даних" для інтеграції різних мікросервісів.




\textbf{6. Виклики та рішення при роботі з Kafka у мікросервісах}

\textit{Консистентність повідомлень:} Як уникнути втрати повідомлень або дублювання під час їх обробки споживачами.

\textit{Управління чергами та партиціями: }Ефективне розподілення партицій між брокерами та споживачами для підвищення продуктивності.

\textit{Транзакції в Kafka:} Як гарантувати атомарність обробки повідомлень у мікросервісах.

\textit{Моніторинг та масштабування Kafka:} Використання інструментів для моніторингу продуктивності Kafka та масштабування системи у разі зростання навантаження.




\textbf{7. Приклади застосування мікросервісної архітектури з Kafka}

\textit{E-commerce платформа:} Використання Kafka для синхронізації даних про замовлення, оплату, інвентаризацію та доставку між мікросервісами.

\textit{IoT-платформи:} Збір даних з IoT-пристроїв у реальному часі з подальшою обробкою через Kafka.

\textit{Фінансові транзакції:} Використання Kafka для обробки платіжних транзакцій з мінімальними затримками та високою надійністю.




\textbf{8. Заключення}

\textit{Підсумок:} Розподілені системи потребують механізмів синхронізації та забезпечення консистентності даних, особливо в умовах мікросервісної архітектури. Використання Apache Kafka дозволяє ефективно вирішувати ці задачі за допомогою асинхронної комунікації та масштабованої передачі повідомлень.





\end{document}

